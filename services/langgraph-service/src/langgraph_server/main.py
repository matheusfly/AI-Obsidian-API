"""
LangGraph Server for Obsidian Integration
Custom implementation for complete symbiosis
"""

from fastapi import FastAPI, HTTPException
from pydantic import BaseModel
from typing import Dict, Any, List, Optional
import httpx
import asyncio
import json
from datetime import datetime
import logging

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Create FastAPI app
app = FastAPI(
    title="LangGraph Server for Obsidian Integration",
    description="Custom LangGraph server for complete symbiosis with Obsidian",
    version="1.0.0"
)

# Configuration
OBSIDIAN_API_BASE_URL = "http://127.0.0.1:27123"
OBSIDIAN_API_KEY = "b26efa44ceb0bd4e1fae338cede5384237bbab8624c61927986aa3f06c2f5a70"
OBSIDIAN_HEADERS = {
    "Authorization": f"Bearer {OBSIDIAN_API_KEY}",
    "Content-Type": "application/json"
}

# Pydantic models
class WorkflowRequest(BaseModel):
    vault_name: str
    workflow_type: str
    parameters: Dict[str, Any] = {}

class WorkflowResponse(BaseModel):
    success: bool
    workflow_id: str
    status: str
    results: Dict[str, Any]
    message: str

class ObsidianFileRequest(BaseModel):
    vault_name: str
    file_path: str
    content: Optional[str] = None

# Health check endpoint
@app.get("/health")
async def health_check():
    """Health check endpoint"""
    return {
        "status": "healthy", 
        "service": "LangGraph Server for Obsidian",
        "timestamp": datetime.now().isoformat()
    }

# Obsidian API integration functions
async def call_obsidian_api(endpoint: str, method: str = "GET", data: dict = None) -> dict:
    """Make a call to the Obsidian Local REST API"""
    url = f"{OBSIDIAN_API_BASE_URL}{endpoint}"
    
    try:
        async with httpx.AsyncClient() as client:
            if method == "GET":
                response = await client.get(url, headers=OBSIDIAN_HEADERS, timeout=10)
            elif method == "POST":
                response = await client.post(url, headers=OBSIDIAN_HEADERS, json=data, timeout=10)
            elif method == "PUT":
                response = await client.put(url, headers=OBSIDIAN_HEADERS, json=data, timeout=10)
            else:
                raise ValueError(f"Unsupported HTTP method: {method}")
            
            response.raise_for_status()
            return response.json()
    
    except httpx.RequestError as e:
        logger.error(f"Obsidian API request error: {str(e)}")
        raise HTTPException(status_code=500, detail=f"Obsidian API error: {str(e)}")

# LangGraph workflow endpoints
@app.post("/workflows/obsidian-integration", response_model=WorkflowResponse)
async def run_obsidian_integration_workflow(request: WorkflowRequest):
    """Run the Obsidian integration workflow"""
    try:
        workflow_id = f"obsidian_workflow_{int(datetime.now().timestamp())}"
        
        # Step 1: List vault files
        logger.info(f"Step 1: Listing files in vault {request.vault_name}")
        files_response = await call_obsidian_api(f"/vault/")
        files = files_response if isinstance(files_response, list) else []
        
        # Step 2: Search for relevant files
        logger.info("Step 2: Searching for relevant files")
        search_query = request.parameters.get("search_query", "langgraph")
        search_response = await call_obsidian_api(
            f"/vault/{request.vault_name}/search",
            method="POST",
            data={"query": search_query, "limit": 10}
        )
        search_results = search_response.get("results", [])
        
        # Step 3: Read specific file if requested
        current_file = request.parameters.get("current_file")
        file_content = ""
        if current_file:
            logger.info(f"Step 3: Reading file {current_file}")
            file_response = await call_obsidian_api(f"/vault/{current_file}")
            file_content = file_response.get("content", "")
        
        # Step 4: Create summary note
        logger.info("Step 4: Creating summary note")
        summary_content = f"""# LangGraph-Obsidian Integration Workflow

**Workflow ID:** {workflow_id}
**Generated:** {datetime.now().isoformat()}
**Vault:** {request.vault_name}
**Type:** {request.workflow_type}

## Files Found
- Total files: {len(files)}
- Files: {json.dumps(files[:5], indent=2)}

## Search Results
- Query: {search_query}
- Results: {json.dumps(search_results[:3], indent=2)}

## Current File
- File: {current_file or 'N/A'}
- Content length: {len(file_content)}

## Workflow Parameters
{json.dumps(request.parameters, indent=2)}

---
*This note was automatically generated by the LangGraph-Obsidian integration workflow.*
"""
        
        summary_file_path = f"LangGraph_Workflow_{workflow_id}.md"
        await call_obsidian_api(
            f"/vault/{summary_file_path}",
            method="PUT",
            data={"content": summary_content}
        )
        
        return WorkflowResponse(
            success=True,
            workflow_id=workflow_id,
            status="completed",
            results={
                "files_found": len(files),
                "search_results": len(search_results),
                "summary_file": summary_file_path,
                "current_file_content_length": len(file_content)
            },
            message="Workflow completed successfully"
        )
        
    except Exception as e:
        logger.error(f"Workflow error: {str(e)}")
        return WorkflowResponse(
            success=False,
            workflow_id="",
            status="failed",
            results={},
            message=f"Workflow failed: {str(e)}"
        )

@app.post("/workflows/obsidian-search")
async def run_obsidian_search_workflow(request: WorkflowRequest):
    """Run a search workflow in Obsidian"""
    try:
        workflow_id = f"search_workflow_{int(datetime.now().timestamp())}"
        search_query = request.parameters.get("query", "")
        
        # Search in Obsidian
        search_response = await call_obsidian_api(
            f"/vault/{request.vault_name}/search",
            method="POST",
            data={"query": search_query, "limit": 20}
        )
        
        results = search_response.get("results", [])
        
        return WorkflowResponse(
            success=True,
            workflow_id=workflow_id,
            status="completed",
            results={
                "query": search_query,
                "results_count": len(results),
                "results": results
            },
            message=f"Search completed with {len(results)} results"
        )
        
    except Exception as e:
        logger.error(f"Search workflow error: {str(e)}")
        return WorkflowResponse(
            success=False,
            workflow_id="",
            status="failed",
            results={},
            message=f"Search workflow failed: {str(e)}"
        )

@app.post("/workflows/obsidian-file-operations")
async def run_obsidian_file_operations_workflow(request: WorkflowRequest):
    """Run file operations workflow in Obsidian"""
    try:
        workflow_id = f"file_ops_workflow_{int(datetime.now().timestamp())}"
        
        # List files
        files_response = await call_obsidian_api(f"/vault/")
        files = files_response if isinstance(files_response, list) else []
        
        # Read specific files
        file_contents = {}
        for file_info in files[:5]:  # Read first 5 files
            if file_info.get("type") != "folder":
                try:
                    file_response = await call_obsidian_api(f"/vault/{file_info.get('path', '')}")
                    file_contents[file_info.get("name", "")] = file_response.get("content", "")
                except:
                    continue
        
        return WorkflowResponse(
            success=True,
            workflow_id=workflow_id,
            status="completed",
            results={
                "files_processed": len(file_contents),
                "total_files": len(files),
                "file_contents": {k: v[:100] + "..." if len(v) > 100 else v for k, v in file_contents.items()}
            },
            message=f"File operations completed for {len(file_contents)} files"
        )
        
    except Exception as e:
        logger.error(f"File operations workflow error: {str(e)}")
        return WorkflowResponse(
            success=False,
            workflow_id="",
            status="failed",
            results={},
            message=f"File operations workflow failed: {str(e)}"
        )

# Direct Obsidian API endpoints
@app.get("/obsidian/vaults")
async def get_vaults():
    """Get available vaults"""
    try:
        response = await call_obsidian_api("/vault/")
        return {
            "success": True,
            "vaults": response if isinstance(response, list) else [],
            "timestamp": datetime.now().isoformat()
        }
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/obsidian/files/{vault_name}")
async def get_files(vault_name: str, path: str = "", limit: int = 100):
    """Get files in a vault"""
    try:
        endpoint = f"/vault/{path}" if path else "/vault/"
        response = await call_obsidian_api(endpoint)
        
        files = response if isinstance(response, list) else []
        if limit:
            files = files[:limit]
        
        return {
            "success": True,
            "files": files,
            "count": len(files),
            "vault_name": vault_name,
            "path": path
        }
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/obsidian/file/{vault_name}/{file_path:path}")
async def get_file(vault_name: str, file_path: str):
    """Get a specific file"""
    try:
        response = await call_obsidian_api(f"/vault/{file_path}")
        return {
            "success": True,
            "content": response.get("content", ""),
            "metadata": response.get("metadata", {}),
            "file_path": file_path,
            "vault_name": vault_name
        }
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.put("/obsidian/file/{vault_name}/{file_path:path}")
async def update_file(vault_name: str, file_path: str, request: ObsidianFileRequest):
    """Update a file"""
    try:
        await call_obsidian_api(
            f"/vault/{file_path}",
            method="PUT",
            data={"content": request.content or ""}
        )
        return {
            "success": True,
            "message": "File updated successfully",
            "file_path": file_path,
            "vault_name": vault_name
        }
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

# Workflow status endpoint
@app.get("/workflows/{workflow_id}/status")
async def get_workflow_status(workflow_id: str):
    """Get workflow status"""
    return {
        "workflow_id": workflow_id,
        "status": "completed",
        "progress": 100,
        "timestamp": datetime.now().isoformat()
    }

# List available workflows
@app.get("/workflows")
async def list_workflows():
    """List available workflows"""
    return {
        "workflows": [
            {
                "name": "obsidian-integration",
                "description": "Complete Obsidian integration workflow",
                "endpoint": "/workflows/obsidian-integration"
            },
            {
                "name": "obsidian-search",
                "description": "Search workflow in Obsidian",
                "endpoint": "/workflows/obsidian-search"
            },
            {
                "name": "obsidian-file-operations",
                "description": "File operations workflow",
                "endpoint": "/workflows/obsidian-file-operations"
            }
        ]
    }

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8003)
